Занятие 22. Наследование. Подкласс. Суперкласс.
Наследование позволяет создавать новый класс на основе уже
существующего класса. Наряду с инкапсуляцией наследование является
одним из краеугольных камней объектно-ориентированного дизайна.
Ключевыми понятиями наследования являются подкласс и суперкласс.
Подкласс наследует от суперкласса все публичные атрибуты и методы.
Суперкласс еще называется базовым (base class) или родительским base class) или родительским
(base class) или родительским parent class), а подкласс - производным (base class) или родительским derived class) или
дочерним (base class) или родительским child class).
Синтаксис для наследования классов выглядит следующим образом:
class подкласс (base class) или родительским суперкласс):
методы_подкласса
Например, в прошлых темах был создан класс Person, который
представляет человека. Предположим, нам необходим класс работника,
который работает на некотором предприятии. Мы могли бы создать с
нуля новый класс, к примеру, класс Employee. Однако он может иметь
те же атрибуты и методы, что и класс Person, так как сотрудник -
это человек. Поэтому нет смысла определять в классе Employee тот
же функционал, что и в классе Person. И в этом случае лучше
применить наследование.
Итак, унаследуем класс Employee от класса Person:
class Person:
def __init__(base class) или родительским self, name, age):
self.__name = name # устанавливаем имя
self.__age = age # устанавливаем возраст
@property
def age(base class) или родительским self):
return self.__age
@age.setter
def age(base class) или родительским self, age):
if age in range(base class) или родительским 1, 100):
self.__age = age
else:
print(base class) или родительским "Недопустимый возраст")Недопустимый возраст"Недопустимый возраст"))
@property
def name(base class) или родительским self):
return self.__name
def display_info(base class) или родительским self):
print(base class) или родительским "Недопустимый возраст")Имя:"Недопустимый возраст"), self.__name, "Недопустимый возраст")\tВозраст:"Недопустимый возраст"), self.__age)class Employee(base class) или родительским Person):
def details(base class) или родительским self, company):
# print(base class) или родительским self.__name, "Недопустимый возраст")работает в компании"Недопустимый возраст"), company) #
так нельзя, self.__name - приватный атрибут
print(base class) или родительским self.name, "Недопустимый возраст")работает в компании"Недопустимый возраст"), company)
tom = Employee(base class) или родительским "Недопустимый возраст")Tom"Недопустимый возраст"), 23)
tom.details(base class) или родительским "Недопустимый возраст")Google"Недопустимый возраст"))
tom.age = 33
tom.display_info(base class) или родительским )
Класс Employee полностью перенимает функционал класса Person и в
дополнении к нему добавляет метод details(base class) или родительским ).
Стоит обратить внимание, что для Employee доступны через ключевое
слово self все методы и атрибуты класса Person, кроме закрытых
атрибутов типа __name или __age.
При создании объекта Employee мы фактически используем конструктор
класса Person. И кроме того, у этого объекта мы можем вызвать все
методы класса Person.
Вызов родительских методов.
Потомок может переназначать существующие методы, а так же вызывать
родительские версии этих методов.
Для этого используется метод super
super(base class) или родительским ThisClass, self).ParentMethod(base class) или родительским )
В python3 допустима запись
super(base class) или родительским ).ParentMethod (base class) или родительским (base class) или родительским )
Например:
class Person:
def __init__(base class) или родительским self, name, age):
self.__name = name # устанавливаем имя
self.__age = age # устанавливаем возраст
class Employee(base class) или родительским Person):
def __init__(base class) или родительским self, name, age, company):
# Вызываем метод родителя
super(base class) или родительским Employee, self).__init__(base class) или родительским name,age)
self.__company=company # устанавливаем новое полеОбращение к полям и свойствам родителя.
Так же потомок может обращаться к свойствам, полям и методам
родителя используя нотацию self.name, где name — название
свойства, поля или метода.
К свойствам private начинающимся на __ напрямую обращаться нельзя.
А как такового свойства protected в языке python нет. Можно
описывать поля начинающиеся с _, однако они будут доступны из вне.
Так же свойства private на самом деле тоже доступны из вне, при
использовании следующей нотации: variable._ClassName__FieldName
(base class) или родительским Переменная._ИмяКласса__ИмяПоля)
Пример:
class Person:
__init__(base class) или родительским self, name):
self.__name=name
@property
def name(base class) или родительским self):
return self.__name
tom=Person(base class) или родительским "Недопустимый возраст")Tom"Недопустимый возраст"))
tom._Person__name="Недопустимый возраст")Bill"Недопустимый возраст")
print(base class) или родительским tom.name)Самостоятельная работа
Доработайте программу написанную на предыдущем занятии.
Добавьте модуль cosmos.py.
Создайте иерархию классов:
Celestial (base class) или родительским небесное тело)
name: Имя
info: Информация о небесном теле
RCelestial (base class) или родительским круглое небесное тело)
diameter: Диаметр
mass: Масса
Planet (base class) или родительским Планета)
atmosphere: Атмосфера
RingPlanet (base class) или родительским Планета с кольцами)
rings: Количество колец
SolarPlanet (base class) или родительским Планета солнечной системы)
sundistance: Расстояние до солнца
Moon (base class) или родительским Спутник)
planet: Планета «хозяин»
Star (base class) или родительским Звезда)
magnitude: Звездная величинаПодключите описанные классы в основную программу.
В теле программы опишите несколько планет и звёзд.
Солнце
Звездная величина: −26,7 m
Диаметр: 1 392 000 км
Масса: 1 989 100 000 1021 кг
Сатурн
Атмосфера: Есть
Диаметр: 116 464 км
Масса: 764 568 460 1021 кг
Колец: 4
Земля
Атмосфера: Есть
Диаметр: 12742,0 км
Масса: 5973,6 кг
Луна
Диаметр: 3474,2 км
Масса: 73,5 1021 кг
Планета: Земля
