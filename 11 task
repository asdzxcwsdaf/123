Занятие 11. Множества
Контрольные вопросы
1. Словарь описывается с использованием скобок
a) ()
b) []
c) {}
d) <>
2. Для обращения к элементам Словаря используются скобки
a) ()
b) []
c) {}
d) <>
3. Для преобразования списка или кортежа в словарь используется
оператор
a) dic
b) bic
c) dict
d) duct
3. Описан словарь:
pip={"Tom": "Green", "Mike": "Black", "Jill": "Brown"}
Как обратиться к третьему элементу?
a) pip[3]
b) pip[2]
c) pip["Brown"]
d) pip["Jill"]
4. Даны два словаря pip и vol. Как скопировать содержимое первого
словаря во второй?
a) pip = vol.copy()
b) vol = pip.copy
c) vol = pip.copy()
d) vol = pip
5. Дан словарь pip, как добавить туда значение "White" с ключём
"Bill"
a) pip.add("White","Bill")
b) pip.insert("White","Bill")
c) pip["White"]="Bill"
d) pip["Bill"]="White"
6. Оператор in позволяет проверить наличие в словаре
a) элемента
b) индекса
c) не применим к словарю
d) элемента и индексаМножество (set) представляют еще один вид набора элементов. Для
определения множества используются фигурные скобки, в которых
перечисляются элементы:
users = {"Tom","Bob","Alice", "Tom"}
print(users) # {"Tom","Bob","Alice"}
Обратите внимание, что несмотря на то, что функция print вывела один раз элемент "Tom", Tom"Tom", ,
хотя в определении множества этот элемент содержится два раза. Все потому что множество
содержит только уникальные значения.
Также для определения множества может применяться функция set(), в которую передается
список или кортеж элементов:
users3 = set(["Mike", "Bill", "Ted"])
Функцию set удобно применять для создания пустого множества:
users = set()
Для получения длины множества применяется встроенная функция len():
users = {"Tom","Bob","Alice"}
print(len(users)} # 3
Добавление элементов
Для добавления одиночного элемента вызывается метод add():
users = set()
users.add("Sam")
print(users)
Удаление элементов
Для удаления одного элемента вызывается метод remove(), в который передается удаляемый
элемент. Но следует учитывать, что если такого элемента не окажется в множестве, то будет
сгенерирована ошибка. Поэтому перед удалением следует проверять на наличие элемента с
помощью оператора in:
users = {"Tom", "Bob", "Alice"}
user = "Tom"
if user in users:
users.remove(user)
print(users) # {"Bob", "Alice"}
Также для удаления можно использовать метод discard(), который не будет генерировать
исключения при отсутствии элемента:
user = "Tim"
users.discard(user)
Для удаления всех элементов вызывается метод clear():
users.clear()Перебор множества
Для перебора элементов можно использовать цикл for:
users = {"Tom","Bob","Alice"}
for user in users:
print(user)
При переборе каждый элемент помещается в переменную user.
Операции с множествами
С помощью метода copy() можно скопировать содержимое одного множества в другую
переменную:
users = {"Tom","Bob","Alice"}
users3 = users.copy()
Метод union() объединяет два множества и возвращает новое множество:
users = {"Tom","Bob","Alice"}
users2 = {"Sam","Kate", "Bob"}
users3 = users.union(users2)
print(users3) # {"Bob", "Alice", "Sam", "Kate", "Tom"}
Вместо метода union мы могли бы использовать операцию логического сложения:
users = {"Tom","Bob","Alice"}
users2 = {"Sam","Kate", "Bob"}
print(users | users2) # {"Bob", "Alice", "Sam", "Kate", "Tom"}
Пересечение множеств позволяет получить только те элементы, которые есть одновременно в
обоих множествах. Метод intersection() производит операцию пересечения множеств и
возвращает новое множество:
users = {"Tom","Bob","Alice"}
users2 = {"Sam","Kate", "Bob"}
users3 = users.intersection(users2)
print(users3) # {"Bob"}
Вместо метода intersection мы могли бы использовать операцию логического умножения:users = {"Tom","Bob","Alice"}
users2 = {"Sam","Kate", "Bob"}
print(users & users2) # {"Bob"}
В этом случае мы получили бы тот же результат.
Еще одна операция - разность множеств возвращает те элементы, которые есть в первом
множестве, но отсутствуют во втором. Для получения разности множеств можно
использовать метод difference или операцию вычитания:
users = {"Tom","Bob","Alice"}
users2 = {"Sam","Kate", "Bob"}
users3 = users.difference(users2)
print(users3) # {"Tom", "Alice"}
print(users - users2) # {"Tom", "Alice"}
Отношения между множествами
Метод issubset позволяет выяснить, является ли текущее множество подмножеством (то есть
частью) другого множества:
users = {"Tom", "Bob", "Alice"}
superusers = {"Sam", "Tom", "Bob", "Alice", "Greg"}
print(users.issubset(superusers)) # True
print(superusers.issubset(users)) # False
Метод issuperset, наоборот, возвращает True, если текущее множество является
надмножеством (то есть содержит) для другого множества:
users = {"Tom", "Bob", "Alice"}
superusers = {"Sam", "Tom", "Bob", "Alice", "Greg"}
print(users.issuperset(superusers)) # False
print(superusers.issuperset(users)) # True
frozen set
Тип frozen set является видом множеств, которое не может быть изменено. Для его создания
используется функция frozenset:
users = frozenset({"Tom", "Bob", "Alice"})
В функцию frozenset передается набор элементов - список, кортеж, другое множество.
В такое множество мы не можем добавить новые элементы, как и удалить из него уже
имеющиеся. Собственно поэтому frozen set поддерживает ограниченный набор операций:• len(s): возвращает длину множества
• x in s: возвращает True, если элемент x присутствует в множестве s
• x not in s: возвращает True, если элемент x отсутствует в множестве s
• s.issubset(t): возвращает True, если t содержит множество s
• s.issuperset(t): возвращает True, если t содержится в множестве s
• s.union(t)
: возвращает объединение множеств s и t
• s.intersection(t): возвращает пересечение множеств s и t
• s.difference(t): возвращает разность множеств s и t
• s.copy(): возвращает копию множества sСамостоятельная работа
Задача 1:
Иван был в Лондоне, Торонто, Мадриде и Мнюхене
Алла была в Дублине, Майами, Торонто и Лондоне
Василина была в Мадриде, Майами, Праге и Берлине
1. Определить множества ivan, alla, vasilina и вывести их на экран
2. Найти и вывести на экран города в которых:
2.1. были Иван и Алла,
2.2. были Алла и Василина,
2.3. были Василина и Иван,
2.4. был Иван, но не была Алла,
2.5. была Василина, но не был Иван
2.6. была Алла, но не была Василина
2.7. были и Анна и Иван и Василина
3. Найти и вывести на экран города, в которых каждый из
путешественников был эксклюзивно, т.е. не общие города
Задача 2:
Используя множества написать функцию для приписывания к числу
приставки «год», «года», «лет».
