Занятие 23. Полиморфизм. Проверка типа объекта. Полиморфизм при
множественном наследовании.
Полиморфизм является еще одним базовым аспектом объектноориентированного программирования и предполагает способность к
изменению функционала, унаследованного от базового класса.
Например, пусть у нас будет следующая иерархия классов:
class Person:
def __init__(self, name, age):
self.__name = name # устанавливаем имя
self.__age = age # устанавливаем возраст
@property
def name(self):
return self.__name
@property
def age(self):
return self.__age
@age.setter
def age(self, age):
if age in range(1, 100):
self.__age = age
else:
print("Недопустимый возраст")
def display_info(self):
print("Имя:", self.__name, "\tВозраст:", self.__age)
class Employee(Person):
# определение конструктора
def __init__(self, name, age, company):
Person.__init__(self, name, age)
self.company = company
# переопределение метода display_info
def display_info(self):
Person.display_info(self)
print("Компания:", self.company)
class Student(Person):
# определение конструктора
def __init__(self, name, age, university):
Person.__init__(self, name, age)
self.university = university
# переопределение метода display_info
def display_info(self):print("Студент", self.name, "учится в университете",
self.university)
people = [Person("Tom", 23), Student("Bob", 19, "Harvard"),
Employee("Sam", 35, "Google")]
for person in people:
person.display_info()
print()
В производном классе Employee, который представляет служащего,
определяется свой конструктор. Так как нам надо устанавливать при
создании объекта еще и компанию, где работает сотрудник. Для этого
конструктор принимает четыре параметра: стандартный параметр self,
параметры name и age и параметр company.
В самом конструкторе Employee вызывается конструктор базового
класса Person. Обращение к методам базового класса имеет следующий
синтаксис:
суперкласс.название_метода(self [, параметры])
Поэтому в конструктор базового класса передаются имя и возраст.
Сам же класс Employee добавляет к функционалу класса Person еще
один атрибут - self.company.
Кроме того, класс Employee переопределяет метод display_info()
класса Person, поскольку кроме имени и возраста необходимо
выводить еще и компанию, в которой работает служащий. И чтобы
повторно не писать код вывода имени и возраста здесь также
происходит обращение к методу базового класса - методу get_info:
Person.display_info(self).
Похожим образом определен класс Student, представляющий студента.
Он также переопределяет конструктор и метод display_info за тем
исключением, что вместо в методе display_info не вызывается версия
этого метода из базового класса.
В основной части программы создается список из трех объектов
Person, в котором два объекта также представляют классы Employee и
Student. И в цикле этот список перебирается, и для каждого объекта
в списке вызывается метод display_info. На этапе выполнения
программы Python учитывает иерархию наследования и выбирает нужную
версию метода display_info() для каждого объекта. В итоге мы
получим следующий консольный вывод:
Имя: Tom Возраст: 23
Студент Bob учится в университете Harvard
Имя: Sam Возраст: 35
Компания: GoogleПроверка типа объекта
При работе с объектами бывает необходимо в зависимости от их типа
выполнить те или иные операции. И с помощью встроенной функции
isinstance() мы можем проверить тип объекта. Эта функция принимает
два параметра:
isinstance(object, type)
Первый параметр представляет объект, а второй - тип, на
принадлежность к которому выполняется проверка. Если объект
представляет указанный тип, то функция возвращает True. Например,
возьмем выше описанную иерархию классов:
for person in people:
if isinstance(person, Student):
print(person.university)
elif isinstance(person, Employee):
print(person.company)
else:
print(person.name)
print()
Множественное наследование в Python
В определенных классах в круглых скобках можно указать сразу
несколько базовых классов через запятую. В этом случае поиск
идентификаторов производится вначале в производном классе, затем в
базовом классе, расположенном первым в списке, далее
просматриваются все базовые классы базового класса. Только после
этого просматривается базовый класс, расположенный в списке
правее, и все его базовые классы. Список базовых классов
просматривается слева направо. Результатом поиска будет первый
найденный идентификатор. Рассмотрим множественное наследование на
примере.
Множественное наследование
class Class1: # Базовый класс для класса Class2
def f_func1(self):
print "Метод f_func1() класса Class1"
class Class2(Class1): # Класс Class2 наследует класс Class1
def f_func2(self):
print "Метод f_func2() класса Class2"
class Class3(Class1): # Класс Class3 наследует класс Class1
def f_func1(self):
print "Метод f_func1() класса Class3"
def f_func2(self):
print "Метод f_func2() класса Class3"
def f_func3(self):
print "Метод f_func3() класса Class3"def f_func4(self):
print "Метод f_func4() класса Class3"
class Class4(Class2, Class3): # Множественное наследование
def f_func4(self):
print "Метод f_func4() класса Class4"
c1 = Class4() # Создаем экземпляр класса Class4
c1.f_func1() # Выведет: Метод f_func1() класса Class1
c1.f_func2() # Выведет: Метод f_func2() класса Class2
c1.f_func3() # Выведет: Метод f_func3() класса Class3
c1.f_func4() # Выведет: Метод f_func4() класса Class4
Итак, метод f_func1() определен в двух классах - Class1 и Class3.
Так как класс Class2 стоит первым в списке базовых классов,
вначале просматривается этот класс, а затем все его базовые
классы. Поэтому метод f_func1() будет найден в классе Class1, а не
в классе Class3.
Метод f_func2() также определен в двух классах - Class2 и Class3.
Так как класс Class2 стоит первым в списке базовых классов, то
метод будет найден именно в этом классе. Чтобы наследовать метод
из класса Class3, следует указать это явным образом. Передаем
определение класса Class4 из предыдущего примера и наследуем метод
f_func2() из класса Class3.
Указание класса при наследовании метода
class Class4(Class2, Class3): # Множественное наследование
# Наследуем f_func2() из класса Class3, а не из класса Class2
f_func2 = Class3.f_func2
def f_func4(self):
print "Метод f_func4() класса Class4"
Метод f_func3() определен только в классе Class3, поэтому метод
наследуется от этого класса. Метод f_func4(), определенный в
классе Class3, переопределяется в производном классе. Если метод
найден в производном классе, то вся иерархия наследования
просматривается не будет.
Если необходимо получить перечень базовых классов, то можно
воспользоваться атрибутом __base__. В качестве значения атрибут
возвращает кортеж. В качестве примера выведем классы для класса
Class4 из предыдущего примера.
print Class4.__bases__Самостоятельная работа
Доработайте программу написанную на предыдущем занятии.
В модуле cosmos.py.
Переделайте описание класса SolarPlanet
Сделайте его наследником двух классов StarPlanet и Planet.
Класс StarPlanet не является наследником Planet добавляет только
свойство stardistance
Переделайте класс RingPlanet, теперь он добавляет свойство rings,
и не является наследником Planet
Опишите новый класс SolarRingPlanet
Подключите описанные классы в основную программу.
В теле программы опишите несколько планет и звёзд, добавьте их в
список SpaceObjects.
Используя цикл, выведите информацию о каждом объекте, определите
является ли объект планетой, спутником или звездой. И выведите эту
информацию на экран. Выведите список классов на которых основан
класс каждого объекта.
Солнце
Звездная величина: −26,7 m
Диаметр: 1 392 000 км
Масса: 1 989 100 000 1021 кг
Сатурн
Атмосфера: Есть
Диаметр: 116 464 км
Расстояние от солнца: 1,434 млрд км
Масса: 764 568 460 1021 кг
Колец: 4Марс:
Атмосфера: Есть
Диаметр: 6 779 км
Расстояние от солнца: 227 900 000
Масса: 639 1021 кг
Земля
Атмосфера: Есть
Расстояние от солнца: 149,6 млн км
Диаметр: 12742,0 км
Масса: 5972 1021 кг
Луна
Диаметр: 3474,2 км
Масса: 73,5 1021 кг
Планета: Земля
